#!./test# -*- mode: sh -*-
# test the fLisp library
# leg20231129: Femto

tap 45

export FLISPRC=../flisp.rc
flisplib() { IN="(require 'flisp) $IN" flisp_expr "$@"; }
flisplib_err() { IN="(require 'flisp) $IN" flisp_err "$@"; }

# null
IN='(null nil)' OUT=t
flisplib 1; ok null-1 nil is null

IN="(null t)" OUT=nil
flisplib 1; ok null-2 t is not null

IN="(null 'symbol)" OUT=nil
flisplib 1; ok null-3 symbol is not null

IN="(null (cons nil nil))" OUT=nil
flisplib 1; ok null-3 cons is not null

# not
IN="(not t)" OUT=nil
flisplib 1; ok not-1 not t is nil

IN="(not nil)" OUT=t
flisplib 1; ok not-2 not nil is t

IN="(not 1)" OUT=nil
flisplib 1; ok not-3 not 1 is nil

IN='(not "a")' OUT=nil
flisplib 1; ok not-4 not string is nil

IN="(not 'a)" OUT=nil
flisplib 1; ok not-5 not symbol is nil

IN="(not '(1))" OUT=nil
flisplib 1; ok not-6 not list is nil


# listp
IN='(listp nil)' OUT=t
flisplib 1; ok listp-1 nil is list

IN='(listp t)' OUT=nil
flisplib 1; ok listp-2 constant is not list

IN="(listp '())" OUT=t
flisplib 1; ok listp-3 single element list is list

IN="(listp '(a 0))" OUT=t
flisplib 1; ok listp-4 two element list is list

IN='(or)' OUT=nil
flisplib 1; ok or-1 empty or is false

IN='(or t)' OUT=t
flisplib 1; ok or-2 t is t

IN='(or "a")' OUT='"a"'
flisplib 1; ok or-3 not nil is itself

IN='(or t nil)' OUT=t
flisplib 1; ok or-4 t nil is t

IN='(or nil t)' OUT=t
flisplib 1; ok or-5 nil t is t

IN='(or nil 0)' OUT=0
flisplib 1; ok or-6 nil not nil is itself

IN='(or nil nil nil)' OUT=nil
flisplib 1; ok or-7 triple nil is nil

IN='(or nil nil nil "a" "b" nil)' OUT='"a"'
flisplib 1; ok or-8 nil with not nil is first itself

# Math

IN='(nthcdr -1 nil)'
ERR="negative index"
OBJ='-1'
flisplib_err 1; ok nthcdr-1 negativ index fails

IN="(nthcdr 0 '(a b c))" OUT='(a b c)'
flisplib 1; ok nthcdr-2 0 index is list

IN="(nthcdr 2 '(a b c))" OUT='(c)'
flisplib 1; ok nthcdr-3 last index is last element

IN="(nthcdr 40 '(a b c))" OUT=nil
flisplib 1; ok nthcdr-4 index over length is nil

IN="(nthcdr 40 nil)" OUT=nil
flisplib 1; ok nthcdr-5 of nil is nil

IN="(nthcdr 1 '(2 . 3))" OUT=3
flisplib 1; ok nthcdr-6 of 1 of cons is cdr

IN="(nthcdr null nil)"
ERR="(nthcdr i l) - i expected type-integer, got: type-primitive"
OBJ='#<Primitive null>'
flisplib_err 1; ok nthcdr-7 wrong index type fails

IN="(nthcdr 1 null)"
ERR="(nthcdr i l) - l expected type-cons, got: type-primitive"
OBJ='#<Primitive null>'
flisplib_err 1; ok nthcdr-8 wrong list type fails

IN="(nth 1 '(a b c))" OUT=b
flisplib 1; ok nth-1 yields element

false; ok foldr-1 \# TODO

true; ok unfold-1 \# TODO unfold is tested by its application in iota

IN="(iota 5)" OUT="(0 1 2 3 4)"
flisplib 1; ok iota-1 iota count gives count

IN="(iota 5 10)" OUT="(10 11 12 13 14)"
flisplib 1; ok iota-1 iota count start gives count from start

IN="(iota 5 10 2)" OUT="(10 12 14 16 18)"
flisplib 1; ok iota-1 iota count step gives count from start by step

# atom
IN='(atom 0)' OUT=t
flisplib 1; ok atom-1 number is atom

IN='(atom "a")' OUT=t
flisplib 1; ok atom-2 string is atom

IN="(atom 'symbol)" OUT=t
flisplib 1; ok atom-3 symbol is atom

IN='(atom nil)' OUT=t
flisplib 1; ok atom-4 nil is atom

IN="(atom '(0 'b))" OUT=nil
flisplib 1; ok atom-5 list is not atom

# zerop
IN='(zerop 0)' OUT=t
flisplib 1; ok zerop-1 0 is zero

IN='(zerop 1)' OUT=nil
flisplib 1; ok zerop-2 1 is not zero

# if
false; ok if \# TODO

# equal
false; ok equal \# TODO
