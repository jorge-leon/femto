#!/bin/sh
# leg20231128
#
# Poor mans unit test framework
#

# Augmented for testing fLisp and femto
#
# fLisp is tested via the flisp command line interpreter, the femto
# editor extensions via the batch mode of femto.
#
# The test files must have an extension .test and the first line must
# indicate if the test is run with flisp or with femto:
#
# fLisp test files are written in POSIX shell and start with a hash: #
# femto test files are written in Lisp and start with a semicolon: ;
#
# In summary mode test output is filtered through ESR's tapview
# program, to get a progress indication and then a summary of
# successful, failed and skipped tests.
#
# Debugging of fLisp test files is done by setting the environment
# variable VERBOSE to 1.
#
# femto test files are run with FEMTO_DEBUG set, debug output is
# written to the file debug.out.
#
# Get information on how to run with the -? command line option.

: ${VERBOSE:=}
: ${SUMMARY:=}
: ${TEST_ALL=}

FLISP=../flispd
FLISP_DEBUG=
FEMTO_DEBUG=

usage () {
    cat <<EOF
Femto test suite

Usage: $0 [OPTION..] [testsuite ..]


Options:

-a .. Run all tests.
-d .. Lisp debugging to debug.out.
-s .. Only show summary for each testsuite.
-v .. Show each execution step.
-? .. Show this text.

-s and -v exclude each other.

Available tests:

$(
    for TESTFILE in *.test; do
        TEST_TYPE="$(head -1 $TESTFILE)"
    	TEST_TYPE="${TEST_TYPE#*mode: }"
   	TEST_TYPE=${TEST_TYPE% -\*-*}

        printf "\t%s\ttype: %s\n" "$TESTFILE" "$TEST_TYPE"
    done
)

Test types:

sh   .. fLisp tests, run with POSIX shell
lisp .. femto tests, run with fLisp tap.lsp

EOF
    exit
}

while getopts adsv? OPT; do
    case $OPT in
	a) TEST_ALL=1;;
	d)
	  export FLISP_DEBUG=debug.out
	  export FEMTO_DEBUG=debug.out
	  ;;
	s) export SUMMARY=1;;
	v) export VERBOSE=1;;
	?) usage;;
    esac
done
shift $((OPTIND-1))	

[ "$VERBOSE" -a "$SUMMARY" ] && usage

# print tap header line
tap() {
    [ "$1" ] && {
	echo TAP version 14
	echo 1..$1
	echo \# $test
    } ||
	trap '[ $? = 0 ] || echo Bail out!; echo 1..$TEST' EXIT
}

# create tap output line. Check $? for success
ok () {
    [ $? != 0 ] && printf "not " && OK=1 || OK=0
    TEST=$((TEST+1)); echo ok $TEST - $@; return $OK
}

# - - -


# pipe expr $PREPARE, then $IN to fLisp, extract $1 last values of
# output, default 1. Filters trailing 't.  Compare output with $OUT
flisp_expr () {
    [ "$( echo -n "$PREPARE $IN" | $FLISP | tail -n ${1:-1})" = "$OUT" ]
}
flisp_err () {
    echo -n "$PREPARE $IN" | $FLISP 2>&1 | tail -n ${1:-1} |{
	read PRE REST
	: $PRE
	: $REST
	MSG=${REST#*, }
	[ "$OBJ" ] && {
	    EOBJ=${REST%%\',*}
	    EOBJ=${EOBJ#*\'}
	    [ "$PRE" = "error:" -a "$MSG" = "$ERR" -a "$OBJ" = "$EOBJ" ]
	    RC=$? ERR= OBJ=
	    return $RC
	}
	[ "$PRE" = "error:" -a "$MSG" = "$ERR" ]
	RC=$? PRE= OBJ=
	return $RC
    }
}

if [ "$SUMMARY" ]; then SUMMARY=./tapview; else SUMMARY=cat; fi

[ "$TEST_ALL" = 1 ] && set -- *.test

[ $# = 0 ] && {
    echo "error: no test file(s) specified\n"
    usage
}
echo $@

for test; do  (
    #mkdir -p tmp
    #rm -rf tmp/*

    echo testsuite: $test

    TEST_TYPE="$(head -1 $test)"
    TEST_TYPE=${TEST_TYPE#*mode: }
    TEST_TYPE=${TEST_TYPE% -\*-*}
    case  "$TEST_TYPE" in
	lisp)
	    [ "$VERBOSE" ] && set -x
	    FLISPLIB=.. FLISPRC=test.lsp ../flispd $test 3>&1 | $SUMMARY
	    ;;
	sh)
	    export FLISPLIB=..
	    [ "$VERBOSE" ] && set -x
	    . ./${test} | $SUMMARY
	    ;;
	*)
	    echo error: cannot detect type of testsuite >&2
	    exit 1
	    ;;
    esac
    set +x
); done
#rm -rf tmp
