#!./test # -*- mode: sh -*-
# test the fLisp core library
# leg20231129: Femto

export FLISPRC=../init.lsp

tap 178

# list
IN='(list)' OUT=nil
flisp_expr 1; ok list-1 empty list

IN="(list 'element)" OUT='(element)'
flisp_expr 1; ok list-2 single element

IN="(list 'first 'second)" OUT='(first second)'
flisp_expr 1; ok list-3 two elements

# defmacro
IN="(defmacro m (a b) (list 'list a b)) (m 1 2)" OUT='(1 2)'
flisp_expr 1; ok defmacro-1  simple macroexpansion

# conditionals
# if
true; ok if \# TODO
# if-not
true; ok if-not \# TODO
# when
true; ok when \# TODO
# unless
true; ok unless \# TODO

# defun
IN="(defun f (a b) (list a b)) (f 1 2)" OUT='(1 2)'
flisp_expr 1; ok defun-1  simple function invocation

# Accessors
IN="(cadr '(a b c d))" OUT="b"
flisp_expr 1; ok cadr-1 cadr returns second element
IN="(cddr '(a b c d))" OUT="(c d)"
flisp_expr 1; ok cddr-1 cddr returns list after second element
IN="(caddr '(a b c d))" OUT="c"
flisp_expr 1; ok caddr-1 caddr returns third element
IN="(caar '((a b) (c d)))" OUT="a"
flisp_expr 1; ok caar-1 caar returns first element of first list
IN="(cdar '((a b c) d))" OUT="(b c)"
flisp_expr 1; ok cdar-1 cdar returns rest of first list

# setq
IN="(setq var 'val)" OUT=val
flisp_expr 1; ok setq-1 assignment returns value

IN="(setq var 'val) var" OUT="val"
flisp_expr 1; ok setq-2 var evaluates to val

IN='(setq)' OUT=nil
flisp_expr 1; ok setq-3 no args evaluate to nil

IN='(setq var1)' OBJ= ERR='(setq [s v ..]) expects a multiple of 2 arguments'
flisp_err 1; ok setq-4 one arg fails

EXPR="(setq var1 'val1  var2 'val2)"
IN="$EXPR" OUT=val2
flisp_expr 1; ok setq-5 four args returns last value

IN="$EXPR var1" OUT=val1
flisp_expr 1; ok setq-6 four args first var evaluates to first value

IN="$EXPR var2" OUT=val2
flisp_expr 1; ok setq-7 four args second var evaluates to second value

IN="((curry + 42) 1)" OUT=43
flisp_expr 1; ok curry-1 curry sum function adds

IN="(typep type-symbol t)" OUT=t
flisp_expr 1; ok typep-1 typep of same type is t

IN="(typep type-string 1)" OUT=nil
flisp_expr 1; ok typep-1 typep of differnt type is nil

IN="(integerp 42)" OUT='t'
flisp_expr 1; ok integerp-1  integerp integer is t

IN="(integerp integerp)" OUT='nil'
flisp_expr 1; ok integerp-2  integerp lambda is nil

IN='(stringp "answer")' OUT='t'
flisp_expr 1; ok stringp-1  stringp string is t

IN="(stringp stringp)" OUT='nil'
flisp_expr 1; ok stringp-2  stringp lambda is nil

IN="(symbolp 'a)" OUT='t'
flisp_expr 1; ok symbolp-1  symbolp symbol is t

IN="(symbolp symbolp)" OUT='nil'
flisp_expr 1; ok symbolp-2  symbolp lambda is nil

IN="(lambdap lambdap)" OUT='t'
flisp_expr 1; ok lambdap-1  lambdap lambda is t

IN="(lambdap 1)" OUT='nil'
flisp_expr 1; ok lambdap-2  lambdap number is nil

IN="(macrop defun)" OUT='t'
flisp_expr 1; ok macrop-1  macrop macro is t

IN="(macrop macrop)" OUT='nil'
flisp_expr 1; ok macrop-2  macrop lambda is nil

IN='(streamp (open "" ">"))' OUT=t
flisp_expr 1; ok streamp-1  streamp stream is t

IN="(streamp streamp)" OUT='nil'
flisp_expr 1; ok streamp-2  streamp lambda is nil

# mapcar
IN="(defun incr (x) (+ x 1)) (mapcar incr '(1 2 3))" OUT="(2 3 4)"
flisp_expr 1; ok mapcar-1 mapcar incr elements in list

IN="(mapcar / '())" OUT="nil"
flisp_expr 1; ok mapcar-2 mapcar does nothing on empty list

# let
## unlabelled let
IN="(let)" OBJ= ERR="(env) expects at least 1 arguments"
flisp_err 1; ok let-1 let errs with zero args

IN="(let ())" OUT=nil
flisp_expr 1; ok let-2 let with empty bindings is nil

IN="(let ((a 1)))" OUT=nil
flisp_expr 1; ok let-3 let with empty body is nil

IN="(setq a 1) (let ((a 2)) a)" OUT=2
flisp_expr 1; ok let-4 let binding shadows outer value

IN="(setq a 1 b 2) (let ((a 3) (b 4)) (list a b))" OUT='(3 4)'
flisp_expr 1; ok let-5 let binds several symbols

## labelled let
IN="(let label)" OUT=nil
flisp_expr 1; ok labelled-let-1 labelled let with empty bindings is nil

IN="(let label ((a 1)))" OUT=nil
flisp_expr 1; ok labelled-let-2 labelled let with empty body is nil

IN="(setq a 1) (let label ((a 2)) a)" OUT=2
flisp_expr 1; ok labelled-let-3 labelled let binding shadows outer value

IN="(setq a 1 b 2) (let label ((a 3) (b 4)) (list a b))" OUT='(3 4)'
flisp_expr 1; ok labelled-let-4 labelled let binds several symbols

IN="(let label ((a 2) (b 0))  (print a) (if (i> a 0) (label (i- a 1) (i+ b 1))))" OUT='210nil'
flisp_expr; ok labelled-let-5 labelled let loops

# let*
IN="(let*)" OBJ= ERR="(env) expects at least 1 arguments"
flisp_err 1; ok 'let*-1 let* errs with zero args'

IN="(let* ())" OUT=nil
flisp_expr 1; ok 'let*-2 let* with empty bindings is nil'

IN="(let* ((a 1)))" OUT=nil
flisp_expr 1; ok 'let*-3 let with empty body is nil'

IN="(setq a 1) (let* ((a 2)) a)" OUT=2
flisp_expr; ok 'let*-4 let* binding shadows outer value'

IN="(let* ((a 3) (b (+ a 1))) (list a b))" OUT='(3 4)'
flisp_expr 1; ok 'let*-5 let* binds recursively symbols'

IN="(prog1 'answer)" OUT="answer"
flisp_expr 1; ok prog1-1 prog1 single arg is arg

IN="(prog1 'answer 42)" OUT="answer"
flisp_expr 1; ok prog1-2 prog1 two args is arg

# string
IN="(string nil)" OUT='""'
flisp_expr 1; ok string-1 nil is empty string

IN="(string 42)" OUT='"42"'
flisp_expr 1; ok string-2 42 is string 42

IN="(string +03)" OUT='"3"'
flisp_expr 1; ok string-3 octal number converts to number string

IN='(string "a")' OUT='"a"'
flisp_expr 1; ok string-4 string returns itself

IN="(string 'a)" OUT='"a"'
flisp_expr 1; ok string-5 symbols converts to its name

IN="(string (cons 'a  2))" OUT='"a2"'
flisp_expr 1; ok string-6 cons converts to concatenated strings of elements

IN="(string car)" OUT='"#<Primitive car>"'
flisp_expr 1; ok string 7 primitive prints reader macro and name

IN="(string (lambda (a b)))" OUT='"#<Lambda (a b)>"'
flisp_expr 1; ok string-8 lambda prints reader macro and parameters

IN="(string (macro (a b)))" OUT='"#<Macro (a b)>"'
flisp_expr 1; ok string-9 macro prints reader macro and parameters

IN='(setq f (open "" "<"))(close f)(string f)' OUT='"#<Stream 0 <STRING>"'
flisp_expr 1; ok string-10 closed stream prints reader macro nil as fd and type

# concat
IN="(concat 1 'a \"?\")" OUT='"1a?"'
flisp_expr 1; ok concat-1 simple string concatenation

true; ok assert-type \# TODO
true; ok assert-number \# TODO

IN="(numberp 42)" OUT='t'
flisp_expr 1; ok numberp-1  numberp number is t

IN="(numberp 3.7)" OUT='t'
flisp_expr 1; ok numberp-2  numberp lambda is nil

IN="(numberp numberp)" OUT='nil'
flisp_expr 1; ok numberp-3  numberp lambda is nil

# list filtering
IN="(filter integerp '(a 1 b 2))" OUT="(1 2)"
flisp_expr;  ok filter-1 filter integers

IN="(filter integerp '())" OUT=nil
flisp_expr;  ok filter-2 filter empty list is nil

IN="(remove integerp '(a 1 b 2))" OUT="(a b)"
flisp_expr;  ok remove-1 remove integers

IN="(remove integerp '())" OUT=nil
flisp_expr;  ok remove-2 remove empty list is nil

IN="(fold-left + 1 nil)" OUT=1
flisp_expr 1;  ok fold-left-1 fold-left with empty list is init
IN="(fold-left + 1 '(2 3))" OUT=6
flisp_expr 1;  ok fold-left-2 fold-left with list folds

IN="((flip -) 2 3)" OUT="1"
flisp_expr 1; ok flip-1 flip - on '2-3' is 1

IN="(reverse '(1 2 3))" OUT="(3 2 1)"
flisp_expr 1; ok reverse-1 reverse 1 2 3 is 3 2 1

# append
IN='(append)' OUT="nil"
flisp_expr 1; ok append-1 append nothing is nil

IN='(append 1)' OUT="1"
flisp_expr 1; ok append-2 append atom is atom

IN="(append '(1 2 3))" OUT="(1 2 3)"
flisp_expr 1; ok append-3 append list is list

IN="(append '(1 2 3) 1)" OUT="(1 2 3 . 1)"
flisp_expr 1; ok append-4 append list atom is dotted list

IN="(append '(1 2 3) '(a b c))" OUT="(1 2 3 a b c)"
flisp_expr 1; ok append-5 append list list is list

IN="(append 1 1)" ERR="(append lists) - list expected type-list, got type-integer" OBJ=
flisp_err 1; ok append-6 append atom any errs

IN="(apply +)" OUT="0"
flisp_expr 1; ok apply-1 apply n-ary + to nothing is 0

IN="(apply + 7)" OUT="7"
flisp_expr 1; ok apply-2 apply n-ary + to 7 is 7

IN="(apply + '(7 4))" OUT="11"
flisp_expr 1; ok apply-3 apply n-ary + to list 7 4 is 11

IN="(apply + 3 4 '(7 4))" OUT="18"
flisp_expr 1; ok apply-4 apply n-ary + to 3 4  and final list 7 4 is 18

false; ok print-1 \# TODO
false; ok princ-1 \# TODO

IN='(string-to-number "42")' OUT='42'
flisp_expr 1; ok string-to-number-1 string 42 is 42

IN='(string-to-number "3.14")' OUT='3.14'
flisp_expr 1; ok string-to-number-2 string 3.14 is 3.14

IN='(string-to-number "answer")' OUT='0'
flisp_expr 1; ok string-to-number-3 not number string is 0

IN="(eq 1 1)" OUT='t'
flisp_expr 1; ok eq-1_1  eq same num is t

IN="(eq 1 2)" OUT='nil'
flisp_expr 1; ok eq-1_2  eq different num is nil

IN="(eq 1 'a)" OUT='nil'
flisp_expr 1; ok eq-1_3  eq num other is nil

IN='(eq "answer" "answer")' OUT='t'
flisp_expr 1; ok eq-2_1  eq same string is t

IN='(eq "answer" "everything")' OUT='nil'
flisp_expr 1; ok eq-2_2  eq different string is nil

IN='(eq "answer" 42)' OUT='nil'
flisp_expr 1; ok eq-2_3  eq string other is nil

IN="(eq 'a 'a)" OUT='t'
flisp_expr 1; ok eq-3_1  eq same symbol is t

IN="(eq 'a eq)" OUT='nil'
flisp_expr 1; ok eq-3_2  eq symbol lambda is nil


IN="(not nil)" OUT="t"
flisp_expr 1;  ok not-1 not t is nil

IN="(not t)" OUT="nil"
flisp_expr 1;  ok not-2 not nil is t

IN="(not 1)" OUT="nil"
flisp_expr 1;  ok not-3 not number is nil


IN="(length nil)" OUT="0"
flisp_expr 1; ok length-1 length of nil is zero

IN="(length '(a b c))" OUT="3"
flisp_expr 1; ok length-2 length of triple list is three


IN='(length "")' OUT="0"
flisp_expr 1; ok length-3 length of empty string is zero

IN='(length "answer")' OUT="6"
flisp_expr 1; ok length-1 length of answer is six

# memq
IN="(memq 'a (list 0 'a 3))" OUT="(a 3)"
flisp_expr 1; ok memq-1 find object in list

IN='(memq '\''a '\''(1 '\''two 3))' OUT=nil
flisp_expr 1; ok memq-2 do not find object in list

IN="(memq nil (list 0 nil 3))" OUT="(nil 3)"
flisp_expr 1; ok memq-3 find nil object in list

true; ok nfold \# TODO is tested by dynamic typed arithmetic
true; ok coerce \# TODO is tested by dynamic typed arithmetic
true; ok coercec \# TODO is tested by dynamic typed arithmetic
true; ok fold-leftp \# TODO is tested by dynamic typed arithmetic

false; ok arith \# TODO  test all of integer, double and misc arith.
IN='(+)' OUT='0' flisp_expr 1; ok add-1 add nothing is 0
IN='(+ 42)' OUT='42' flisp_expr 1; ok add-2 add 42  is 42
IN='(+ 1 2 3)' OUT='6' flisp_expr 1; ok add-4 add 1 2 3 is 6
IN='(-)' OUT='0' flisp_expr 1; ok minus-1 minus nothing is 0
IN='(- 42)' OUT='-42' flisp_expr 1; ok minus-2 minus 42  is -42
IN='(- 1 2 3)' OUT='-4' flisp_expr 1; ok minus-4 minus 1 2 3 is -4
IN='(*)' OUT='1' flisp_expr 1; ok times-1 times nothing is 1
IN='(* 42)' OUT='42' flisp_expr 1; ok times-2 times 42  is 42
IN='(* 1 2 3)' OUT='6' flisp_expr 1; ok times-4 times 1 2 3 is 6
IN='(/ 42.0)' OUT='0.0238095' flisp_expr 1; ok divide-1 divide 42  is 1/42
IN='(/ 42 7 6)' OUT='1' flisp_expr 1; ok divide-3 divide 42 7 6 is 1
IN='(% 42)' OUT='1' flisp_expr 1; ok mod-1 mod 42  is 1
IN='(% 11 6 3)' OUT='2' flisp_expr 1; ok mod-3 mod 11 6 3 is 2
# IN='(= 42)' OUT='t' flisp_expr 1; ok arith-equal-1 arith-equal 42  is t
# IN='(= 7 7 7)' OUT='t' flisp_expr 1; ok arith-equal-3 arith-equal 7 7 7 is t
# IN='(= 7 7 8)' OUT='nil' flisp_expr 1; ok arith-equal-4 arith-equal 7 7 8 is nil
# IN='(< 42)' OUT='t' flisp_expr 1; ok less-1 less 42  is t
# IN='(< 7 7 7)' OUT='nil' flisp_expr 1; ok less-3 less 7 7 7 is nil
# IN='(< 1 2 3)' OUT='t' flisp_expr 1; ok less-4 less 1 2 3 is t
# IN='(<= 42)' OUT='t' flisp_expr 1; ok less-equal-1 less-equal 42  is t
# IN='(<= 7 7 7)' OUT='t' flisp_expr 1; ok less-equal-3 less-equal 7 7 7 is t
# IN='(<= 7 7 6)' OUT='nil' flisp_expr 1; ok less-equal-4 less-equal 7 7 6 is nil
# IN='(> 42)' OUT='t' flisp_expr 1; ok greater-1 greater 42  is t
# IN='(> 7 7 7)' OUT='nil' flisp_expr 1; ok greater-3 greater 7 7 7 is nil
# IN='(> 7 7 6)' OUT='nil' flisp_expr 1; ok greater-4 greater 7 7 6 is nil
# IN='(>= 42)' OUT='t' flisp_expr 1; ok greater-equal-1 greater-equal 42  is t
# IN='(>= 7 7 7)' OUT='t' flisp_expr 1; ok greater-equal-3 greater-equal 7 7 7 is t
# IN='(>= 7 7 6)' OUT='t' flisp_expr 1; ok greater-equal-4 greater-equal 7 7 6 is t

IN='(min)'
ERR="(env) expects at least 1 arguments"
OBJ='#<Lambda (n . args)>'
flisp_err 1; ok min-1 with nil fails

IN='(min "a")'
ERR="(min n[ arg ..]) n: expected number, got type-string"
OBJ='"a"'
flisp_err 1; ok min-2 with not number fails

IN='(min 0)' OUT=0
flisp_expr 1; ok min-3 with single number yields number

IN='(min 1 2)' OUT=1
flisp_expr 1; ok min-4 with 'a<b' yields a

IN='(min 2 1)' OUT=1
flisp_expr 1; ok min-5 with 'a>b' yields b

IN='(min 1 2 3)' OUT=1
flisp_expr 1; ok min-6 with more then two args

IN='(max)'
ERR="(env) expects at least 1 arguments"
OBJ='#<Lambda (n . args)>'
flisp_err 1; ok max-1 with nil fails

IN='(max "a")'
ERR="(max n[ arg ..]) n: expected number, got type-string"
OBJ='"a"'
flisp_err 1; ok max-2 with not number fails

IN='(max 0)' OUT=0
flisp_expr 1; ok max-3 with single number yields number

IN='(max 2 1)' OUT=2
flisp_expr 1; ok max-4 with 'a>b' yields a

IN='(max 1 2)' OUT=2
flisp_expr 1; ok max-5 with 'a<b' yields b

IN='(max 1 2 3)' OUT=3
flisp_expr 1; ok max-6 with more then two args

# or
IN='(or)' OUT=nil
flisp_expr; ok or-1 empty or is false

IN='(or t)' OUT=t
flisp_expr; ok or-2 t is t

IN='(or "a")' OUT='"a"'
flisp_expr; ok or-3 not nil is itself

IN='(or t nil)' OUT=t
flisp_expr; ok or-4 t nil is t

IN='(or nil t)' OUT=t
flisp_expr; ok or-5 nil t is t

IN='(or nil 0)' OUT=0
flisp_expr; ok or-6 nil not nil is itself

IN='(or nil nil nil)' OUT=nil
flisp_expr; ok or-7 triple nil is nil

IN='(or nil nil nil "a" "b" nil)' OUT='"a"'
flisp_expr; ok or-8 nil with not nil is first itself

# and
IN='(and)' OUT=t
flisp_expr 1; ok and-1  no args is t

IN='(and t)' OUT=t
flisp_expr 1; ok and-2  t is t

IN='(and nil)' OUT=nil
flisp_expr 1; ok and-3  nil is nil

IN='(and t nil)' OUT=nil
flisp_expr 1; ok and-4  t nil is nil

IN='(and nil t)' OUT=nil
flisp_expr 1; ok and-5  nil t is nil

IN='(and nil nil)' OUT=nil
flisp_expr 1; ok and-6  nil nil is nil

IN='(and t t)' OUT=t
flisp_expr 1; ok and-7 t t is t

IN='(and "a")' OUT='"a"'
flisp_expr 1; ok and-8 single not nil is itself

IN='(and t "a")' OUT='"a"'
flisp_expr 1; ok and-9 not nil at end is itself

IN='(and "a" 0 t)' OUT=t
flisp_expr 1; ok and-10 triple t is true

IN='(defun aa (p) (and p p)) (aa nil)' OUT=nil
flisp_expr 1; ok and-11 macro env not working

IN='(join ":" nil)' OUT='""'
flisp_expr 1; ok join-1 join nil is empty string

IN='(join ":" (list "a"))' OUT='"a"'
flisp_expr 1; ok join-2 join single list is string

IN='(join ":" (list "a" "b"))' OUT='"a:b"'
flisp_expr 1; ok join-3 join two elements contains separator

IN='(join ":" (list "a" "b" "c"))' OUT='"a:b:c"'
flisp_expr 1; ok join-4 join several contains several separators

IN='(join "" (list "a" "b" "c"))' OUT='"abc"'
flisp_expr 1; ok join-5 join with empty separator concats

IN='(join "nswe" (list "a" "r"))' OUT='"answer"'
flisp_expr 1; ok join-6 with long separator inserts long separator


# fload
IN='(setq f (open "empty.lsp" "r")) (fload f)' OUT=nil
flisp_expr 1; ok fload-1 load empty file

IN='(setq f (open "one_word.lsp" "r")) (fload f)' OUT='"one_word"'
flisp_expr 1; ok fload-2 load file with one word

# load
IN='(load "empty.lsp")' OUT=nil
flisp_expr 1; ok load-1 load empty file

IN='(load "one_word.lsp")' OUT='"one_word"'
flisp_expr 1; ok load-2 load file with one word

# provide
IN="(provide)" OUT="(nil core)"
flisp_expr 1; ok provide-1 providing nothing adds nil
IN="(provide 'a)" OUT="(a core)"
flisp_expr 1; ok provide-2 providing feature a prepends a to features
IN="(provide 'a 'b)" OUT="(a core)"
flisp_expr 1; ok provide-3 providing features a and subfeature b only prepends a to features

# require
IN="(require)" OBJ="#<Lambda (feature . args)>" ERR="(env) expects at least 1 arguments"
flisp_err 1; ok require-1 requiring nothing errs

IN="(require '_no_file)" OUT="nil"
flisp_expr 1; ok require-2 requiring not existing features returns nil

IN="(require 'core)" OUT="core"
flisp_expr 1; ok require-3 requiring existing feature returns feature

IN="(require 'flisp)" OUT="flisp"
flisp_expr 1; ok require-4 requiring new feature returns feature
