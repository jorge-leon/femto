#!./test# -*- mode: sh -*-
# test the fLisp library
# leg20231129: Femto

tap 31

export FLISPRC=../init.lsp
export PREPARE="(require 'flisp)"

# listp
IN='(listp nil)' OUT=t
flisp_expr; ok listp-1 nil is list

IN='(listp t)' OUT=nil
flisp_expr; ok listp-2 constant is not list

IN="(listp '())" OUT=t
flisp_expr; ok listp-3 single element list is list

IN="(listp '(a 0))" OUT=t
flisp_expr; ok listp-4 two element list is list


# Math

IN='(nthcdr -1 nil)'
ERR="negative index"
OBJ='-1'
flisp_err; ok nthcdr-1 negativ index fails

IN="(nthcdr 0 '(a b c))" OUT='(a b c)'
flisp_expr; ok nthcdr-2 0 index is list

IN="(nthcdr 2 '(a b c))" OUT='(c)'
flisp_expr; ok nthcdr-3 last index is last element

IN="(nthcdr 40 '(a b c))" OUT=nil
flisp_expr; ok nthcdr-4 index over length is nil

IN="(nthcdr 40 nil)" OUT=nil
flisp_expr; ok nthcdr-5 of nil is nil

IN="(nthcdr 1 '(2 . 3))" OUT=3
flisp_expr; ok nthcdr-6 of 1 of cons is cdr

IN="(nthcdr null nil)"
ERR="(nthcdr i l) - i expected type-integer, got: type-primitive"
OBJ='#<Primitive null>'
flisp_err; ok nthcdr-7 wrong index type fails

IN="(nthcdr 1 null)"
ERR="(nthcdr i l) - l expected type-cons, got: type-primitive"
OBJ='#<Primitive null>'
flisp_err; ok nthcdr-8 wrong list type fails

IN="(nth 1 '(a b c))" OUT=b
flisp_expr; ok nth-1 yields element

true; ok fold-right-1 \# TODO

true; ok unfold-1 \# TODO unfold is tested by its application in iota

IN="(iota 5)" OUT="(0 1 2 3 4)"
flisp_expr; ok iota-1 iota count gives count

IN="(iota 5 10)" OUT="(10 11 12 13 14)"
flisp_expr; ok iota-1 iota count start gives count from start

IN="(iota 5 10 2)" OUT="(10 12 14 16 18)"
flisp_expr; ok iota-1 iota count step gives count from start by step

# property lists

IN="(prop-get '(a 1 b 2 c) 'a)" OUT="1"
flisp_expr; ok prop-get-1 prop-get first is first

IN="(prop-get '(a 1 b 2 c) 'b)" OUT="2"
flisp_expr; ok prop-get-2 prop-get second is second

IN="(prop-get '(a 1 b 2 c) 'c)" OUT="nil"
flisp_expr; ok prop-get-3 prop-get last w/o value is nil

IN="(prop-get '(a 1 b 2 c 3) 'c)" OUT="3"
flisp_expr; ok prop-get-4 prop-get last with value is last

true; ok prop-get-5 \# TODO prop-get with predicate

# atom
IN='(atom 0)' OUT=t
flisp_expr; ok atom-1 number is atom

IN='(atom "a")' OUT=t
flisp_expr; ok atom-2 string is atom

IN="(atom 'symbol)" OUT=t
flisp_expr; ok atom-3 symbol is atom

IN='(atom nil)' OUT=t
flisp_expr; ok atom-4 nil is atom

IN="(atom '(0 'b))" OUT=nil
flisp_expr; ok atom-5 list is not atom

# zerop
IN='(zerop 0)' OUT=t
flisp_expr; ok zerop-1 0 is zero

IN='(zerop 1)' OUT=nil
flisp_expr 1; ok zerop-2 1 is not zero

# equal
true; ok equal \# TODO
